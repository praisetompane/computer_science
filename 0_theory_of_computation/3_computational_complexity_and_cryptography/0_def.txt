def: deals with what makes some problems COMPUTATIONALLY HARD and others EASY? (Sipser. 2012:2).    
    NB: we don't have an answer yet(40+ years of research) (Sipser. 2012:2).

provides:
    elegant scheme for classifying problems according to computational difficulty (Sipser. 2012:2).
        using the scheme: 
            we can demonstrate a METHOD for GIVING EVIDENCE
                that a problem is computationally hard, even if we CAN'T PROVE it (Sipser. 2012:2).

when confronted with a problem that seems computationally difficulty (Sipser. 2012:2):
    Option 1: Understand which aspect(s) of the problem are the root of the difficulty
                Attempt to rephrase them in a way that is easily solvable
    Option 2: You may be able to settle for a less than perfect solution to the problem
    Option 3: Some problems are only hard at the worst case and easy for all other cases.
                Determine if yours is one of these.
                    Is it fine if it runs fast most of the time and slow once in a while?
    Option 4: Consider other types of computation, that might speed up certain tasks/aspects.
        e.g. random computation.

impact (Sipser. 2012:2):
    cryptography: 
        needs computationally difficult problems to design codes
            complexity theory helps identify the problems

Leverages concepts from Computability theory.

References:
    Sipser, M. 2012. Introduction to the Theory of Computation. Cengage Learning.